<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>welcome wuxBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="welcome wuxBlog">
<meta property="og:url" content="https://wzg6662.github.io/index.html">
<meta property="og:site_name" content="welcome wuxBlog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Wuzg">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/wzg6662.github.io/atom.xml" title="welcome wuxBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/wzg6662.github.io/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/wzg6662.github.io/" id="logo">welcome wuxBlog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/wzg6662.github.io/">Home</a>
        
          <a class="main-nav-link" href="/wzg6662.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/wzg6662.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wzg6662.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-设计模式 - 单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/wzg6662.github.io/2021/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2021-03-03T15:18:23.000Z" itemprop="datePublished">2021-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/wzg6662.github.io/2021/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">设计模式 - 单例模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>开篇我就给大家一个思考题</strong>：为什么不用静态方法而用单例模式？ </p>
<p>首先给单例下一个定义：<strong>在当前进程中，通过单例模式创建的类有且只有一个实例</strong>。</p>
<p>单例有如下几个特点：</p>
<ul>
<li>在Java应用中，单例模式能保证在一个JVM中，该对象只有一个实例存在</li>
<li>构造器必须是私有的，外部类无法通过调用构造器方法创建该实例</li>
<li>没有公开的set方法，外部类无法调用set方法创建该实例</li>
<li>提供一个公开的get方法获取唯一的这个实例</li>
</ul>
<p>那单例模式有什么好处呢？</p>
<ul>
<li>某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销</li>
<li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力</li>
<li>系统中某些类，如spring里的controller，控制着处理流程，如果该类可以创建多个的话，系统完全乱了</li>
<li>避免了对资源的重复占用</li>
</ul>
<p>好了，单例模式的定义也清楚了，好处也了解了，先看一个饿汉式的写法</p>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个实例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，防止被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态get方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以叫饿汉式大家可以理解为他饿，他想提前把对象new出来，这样别人哪怕是<strong>第一次</strong>获取这个类对象的时候直接就存在这个类了，省去了创建类这一步的开销。</p>
<p>等我介绍完懒汉之后，对比一下大家就知道两者的区别，以及各自适用在什么场景了。</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>线程不安全的模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式大家可以理解为他懒，别人<strong>第一次</strong>调用的时候他发现自己的实例是空的，然后去初始化了，再赋值，后面的调用就和饿汉没区别了。</p>
<p>懒汉和饿汉的对比：大家可以发现两者的区别基本上就是第一次创作时候的开销问题，以及线程安全问题（线程不安全模式的懒汉）。</p>
<p>那有了这个对比，那他们的场景好理解了，在很多电商场景，如果这个数据是经常访问的热点数据，那我就可以在系统启动的时候使用饿汉模式提前加载（类似缓存的预热）这样哪怕是第一个用户调用都不会存在创建开销，而且调用频繁也不存在内存浪费了。</p>
<p>而懒汉式呢我们可以用在不怎么热的地方，比如那个数据你不确定很长一段时间是不是有人会调用，那就用懒汉，如果你使用了饿汉，但是过了几个月还没人调用，提前加载的类在内存中是有资源浪费的。</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>上面的懒汉我是故意没加锁的，大家肯定都知道懒汉的线程安全问题的吧？ </p>
<p>在运行过程中可能存在这么一种情况：多个线程去调用getInstance方法来获取Singleton的实例，那么就有可能发生这样一种情况，当第一个线程在执行if（instance==null）时，此时instance是为null的进入语句。</p>
<p>在还没有执行instance=new Singleton()时（此时instance是为null的）第二个线程也进入了if(instance==null)这个语句，因为之前进入这个语句的线程中还没有执行instance=new Singleton()，所以它会执行instance = new Singleton()来实例化Singleton对象，因为第二个线程也进入了if语句所以它会实例化Singleton对象。</p>
<p>这样就导致了实例化了两个Singleton对象，那怎么解决？</p>
<p>简单粗暴，加锁就好了，这是加锁之后的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，防止被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态get方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种典型的时间换空间的写法，不管三七二十一，每次创建实例时先锁起来，再进行判断，严重降低了系统的处理速度。</p>
<p>有没有更好的处理方式呢？</p>
<p>有，通过双检锁做两次判断，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步块，线程安全的创建实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//再次检查实例是否存在，如果不存在才真正的创建实例</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。</p>
<p>但是，这样就没有问题了吗？</p>
<p>看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。</p>
<p>但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。</p>
<p>这样就可能出错了，我们以A、B两个线程为例：</p>
<ol>
<li><p>A、B线程同时进入了第一个if判断</p>
</li>
<li><p>A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();</p>
</li>
<li><p>由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。</p>
</li>
<li><p>B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。</p>
</li>
<li><p>此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。</p>
</li>
</ol>
<p>加上volatile修饰Singleton，再做一次优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步块，线程安全的创建实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//再次检查实例是否存在，如果不存在才真正的创建实例</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**通过volatile修饰的变量，不会被线程本地缓存，所有线程对该对象的读写都会第一时间同步到主内存，从而保证多个线程间该对象的准确性 **</p>
<p><strong>volatile的作用</strong></p>
<ul>
<li>防止指令重排序，因为instance = new Singleton()不是原子操作</li>
<li>保证内存可见</li>
</ul>
<p>这个是比较完美的写法了，这种方式能够安全的创建唯一的一个实例，又不会对性能有太大的影响。</p>
<p>但是由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高，还有更优的写法吗？</p>
<p>通过静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 私有构造方法，防止被实例化 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 此处使用一个内部类来维护单例 */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取实例 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonFactory.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> getInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。</p>
<p>这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕， 这样我们就不用担心上面的问题。</p>
<p>同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式。</p>
<p>还有更完美的写法吗，通过枚举：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义一个枚举的元素，它就代表了Singleton的一个实例。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举来实现单实例控制会更加简洁，而且JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。</p>
<p>最后这种也是我最青睐的一种（代码少）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后大家应该都知道单例模式的写法了，也知道优劣势和使用场景了，那开头的那个问题大家心里有答案了么？</p>
<p>什么？连问题都忘了？问题：为什么不用静态方法而用单例模式？</p>
<p>两者其实都能实现我们加载的最终目的，但是他们一个是基于对象，一个是面向对象的，就像我们不面向对象也能解决问题一样，面向对象的代码提供一个更好的编程思想。</p>
<p>如果一个方法和他所在类的实例对象无关，那么它就应该是静态的，反之他就应该是非静态的。如果我们确实应该使用非静态的方法，但是在创建类时又确实只需要维护一份实例时，就需要用单例模式了。</p>
<p>我们的电商系统中就有很多类，有很多配置和属性，这些配置和属性是一定存在了，又是公共的，同时需要在整个生命周期中都存在，所以只需要一份就行，这个时候如果需要我再需要的时候new一个，再给他分配值，显然是浪费内存并且再赋值没什么意义。</p>
<p>所以我们用单例模式或静态方法去维持一份这些值有且只有这一份值，但此时这些配置和属性又是通过面向对象的编码方式得到的，我们就应该使用单例模式，或者不是面向对象的，但他本身的属性应该是面对对象的，我们使用静态方法虽然能同样解决问题，但是最好的解决方案也应该是使用单例模式。</p>
<p>转自公众号，三太子敖丙<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dW0L-PoBeTFHhD29HJO0BQ">https://mp.weixin.qq.com/s/dW0L-PoBeTFHhD29HJO0BQ</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wzg6662.github.io/2021/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" data-id="cklugg0w200001pp4hbc867mo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="tag">单例模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-github-国内镜像" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/wzg6662.github.io/2021/03/03/github-%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/" class="article-date">
  <time datetime="2021-03-03T03:23:22.000Z" itemprop="datePublished">2021-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/wzg6662.github.io/2021/03/03/github-%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/">github 国内镜像</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><a target="_blank" rel="noopener" href="https://github.com.cnpmjs.org/">github.com.cnpmjs.org</a>（亲测这个访问速度较快）和<a target="_blank" rel="noopener" href="https://git.sdut.me/">git.sdut.me</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wzg6662.github.io/2021/03/03/github-%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/" data-id="ckluan1z20000xzp4a6hn08ci" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/git/" rel="tag">git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/github/" rel="tag">github</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-redis内存耗尽后处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/wzg6662.github.io/2020/10/03/redis%E5%86%85%E5%AD%98%E8%80%97%E5%B0%BD%E5%90%8E%E5%A4%84%E7%90%86/" class="article-date">
  <time datetime="2020-10-03T03:18:23.000Z" itemprop="datePublished">2020-10-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/wzg6662.github.io/2020/10/03/redis%E5%86%85%E5%AD%98%E8%80%97%E5%B0%BD%E5%90%8E%E5%A4%84%E7%90%86/">Redis内存耗尽后会怎么样处理？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一台服务器来说，内存并不是无限的，所以总会存在内存耗尽的情况，那么当 <code>Redis</code> 服务器的内存耗尽后，如果继续执行请求命令，<code>Redis</code> 会如何处理呢？</p>
<h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><p>使用<code>Redis</code> 服务时，很多情况下某些键值对只会在特定的时间内有效，为了防止这种类型的数据一直占有内存，我们可以给键值对设置有效期。<code>Redis</code> 中可以通过 <code>4</code> 个独立的命令来给一个键设置过期时间：</p>
<ul>
<li><code>expire key ttl</code>：将 <code>key</code> 值的过期时间设置为 <code>ttl</code> <strong>秒</strong>。</li>
<li><code>pexpire key ttl</code>：将 <code>key</code> 值的过期时间设置为 <code>ttl</code> <strong>毫秒</strong>。</li>
<li><code>expireat key timestamp</code>：将 <code>key</code> 值的过期时间设置为指定的 <code>timestamp</code> <strong>秒数</strong>。</li>
<li><code>pexpireat key timestamp</code>：将 <code>key</code> 值的过期时间设置为指定的 <code>timestamp</code> <strong>毫秒数</strong>。</li>
</ul>
<p>PS：不管使用哪一个命令，最终 <code>Redis</code> 底层都是使用 <code>pexpireat</code> 命令来实现的。另外，<code>set</code> 等命令也可以设置 <code>key</code> 的同时加上过期时间，这样可以保证设值和设过期时间的原子性。</p>
<p>设置了有效期后，可以通过 <code>ttl</code> 和 <code>pttl</code> 两个命令来查询剩余过期时间（如果未设置过期时间则下面两个命令返回 <code>-1</code>，如果设置了一个非法的过期时间，则都返回 <code>-2</code>）：</p>
<ul>
<li><code>ttl key</code> 返回 <code>key</code> 剩余过期秒数。</li>
<li><code>pttl key</code> 返回 <code>key</code> 剩余过期的毫秒数。</li>
</ul>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>如果将一个过期的键删除，我们一般都会有三种策略：</p>
<ul>
<li>定时删除：为每个键设置一个定时器，一旦过期时间到了，则将键删除。这种策略对内存很友好，但是对 <code>CPU</code> 不友好，因为每个定时器都会占用一定的 <code>CPU</code> 资源。</li>
<li>惰性删除：不管键有没有过期都不主动删除，等到每次去获取键时再判断是否过期，如果过期就删除该键，否则返回键对应的值。这种策略对内存不够友好，可能会浪费很多内存。</li>
<li>定期扫描：系统每隔一段时间就定期扫描一次，发现过期的键就进行删除。这种策略相对来说是上面两种策略的折中方案，需要注意的是这个定期的频率要结合实际情况掌控好，使用这种方案有一个缺陷就是可能会出现已经过期的键也被返回。</li>
</ul>
<p>在 <code>Redis</code> 当中，其选择的是策略 <code>2</code> 和策略 <code>3</code> 的综合使用。不过 <code>Redis</code> 的定期扫描只会扫描设置了过期时间的键，因为设置了过期时间的键 <code>Redis</code> 会单独存储，所以不会出现扫描所有键的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict; <span class="comment">//所有的键值对</span></span><br><span class="line">    dict *expires; <span class="comment">//设置了过期时间的键值对</span></span><br><span class="line">   dict *blocking_keys; <span class="comment">//被阻塞的key,如客户端执行BLPOP等阻塞指令时</span></span><br><span class="line">   dict *watched_keys; <span class="comment">//WATCHED keys</span></span><br><span class="line">   <span class="keyword">int</span> id; <span class="comment">//Database ID</span></span><br><span class="line">   <span class="comment">//... 省略了其他属性</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<h2 id="8-种淘汰策略"><a href="#8-种淘汰策略" class="headerlink" title="8 种淘汰策略"></a>8 种淘汰策略</h2><p>假如 <code>Redis</code> 当中所有的键都没有过期，而且此时内存满了，那么客户端继续执行 <code>set</code> 等命令时 <code>Redis</code> 会怎么处理呢？<code>Redis</code> 当中提供了不同的淘汰策略来处理这种场景。</p>
<p>首先 <code>Redis</code> 提供了一个参数 <code>maxmemory</code> 来配置 <code>Redis</code> 最大使用内存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure>

<p>或者也可以通过命令 <code>config set maxmemory 1GB</code> 来动态修改。</p>
<p>如果没有设置该参数，那么在 <code>32</code> 位的操作系统中 <code>Redis</code> 最多使用 <code>3GB</code> 内存，而在 <code>64</code> 位的操作系统中则不作限制。</p>
<p><code>Redis</code> 中提供了 <code>8</code> 种淘汰策略，可以通过参数 <code>maxmemory-policy</code> 进行配置：</p>
<table>
<thead>
<tr>
<th>淘汰策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>volatile-lru</td>
<td>根据 LRU 算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>根据 LRU 算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td>
</tr>
<tr>
<td>volatile-lfu</td>
<td>根据 LFU 算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td>
</tr>
<tr>
<td>allkeys-lfu</td>
<td>根据 LFU 算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td>
</tr>
<tr>
<td>volatile-random</td>
<td>随机删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>随机删除所有键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>根据键值对象的 ttl 属性， 删除最近将要过期数据。 如果没有，则直接报错</td>
</tr>
<tr>
<td>noeviction</td>
<td>默认策略，不作任何处理，直接报错</td>
</tr>
</tbody></table>
<p>PS：淘汰策略也可以直接使用命令 <code>config set maxmemory-policy &lt;策略&gt;</code> 来进行动态配置。</p>
<h2 id="LRU-算法"><a href="#LRU-算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h2><p><code>LRU</code> 全称为：<code>Least Recently Used</code>。即：最近最长时间未被使用。这个主要针对的是使用时间。</p>
<h3 id="Redis-改进后的-LRU-算法"><a href="#Redis-改进后的-LRU-算法" class="headerlink" title="Redis 改进后的 LRU 算法"></a>Redis 改进后的 LRU 算法</h3><p>在 <code>Redis</code> 当中，并没有采用传统的 <code>LRU</code> 算法，因为传统的 <code>LRU</code> 算法存在 <code>2</code> 个问题：</p>
<ul>
<li>需要额外的空间进行存储。</li>
<li>可能存在某些 <code>key</code> 值使用很频繁，但是最近没被使用，从而被 <code>LRU</code> 算法删除。</li>
</ul>
<p>为了避免以上 <code>2</code> 个问题，<code>Redis</code> 当中对传统的 <code>LRU</code> 算法进行了改造，<strong>通过抽样的方式进行删除</strong>。</p>
<p>配置文件中提供了一个属性 <code>maxmemory_samples 5</code>，默认值就是 <code>5</code>，表示随机抽取 <code>5</code> 个 <code>key</code> 值，然后对这 <code>5</code> 个 <code>key</code> 值按照 <code>LRU</code> 算法进行删除，所以很明显，<code>key</code> 值越大，删除的准确度越高。</p>
<p>对抽样 <code>LRU</code> 算法和传统的 <code>LRU</code> 算法，<code>Redis</code> 官网当中有一个对比图：</p>
<ul>
<li>浅灰色带是被删除的对象。</li>
<li>灰色带是未被删除的对象。</li>
<li>绿色是添加的对象。</li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/2232223/202102/2232223-20210215094536691-559224923.png" alt="img"></p>
<p>左上角第一幅图代表的是传统 <code>LRU</code> 算法，可以看到，当抽样数达到 <code>10</code> 个（右上角），已经和传统的 <code>LRU</code> 算法非常接近了。</p>
<h3 id="Redis-如何管理热度数据"><a href="#Redis-如何管理热度数据" class="headerlink" title="Redis 如何管理热度数据"></a>Redis 如何管理热度数据</h3><p>前面我们讲述字符串对象时，提到了 <code>redisObject</code> 对象中存在一个 <code>lru</code> 属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;<span class="comment">//对象类型（4位=0.5字节）</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">//编码（4位=0.5字节）</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS;<span class="comment">//记录对象最后一次被应用程序访问的时间（24位=3字节）</span></span><br><span class="line">    <span class="keyword">int</span> refcount;<span class="comment">//引用计数。等于0时表示可以被垃圾回收（32位=4字节）</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;<span class="comment">//指向底层实际的数据存储结构，如：SDS等(8字节)</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p><code>lru</code> 属性是创建对象的时候写入，对象被访问到时也会进行更新。正常人的思路就是最后决定要不要删除某一个键肯定是用当前时间戳减去 <code>lru</code>，差值最大的就优先被删除。但是 <code>Redis</code> 里面并不是这么做的，<code>Redis</code> 中维护了一个全局属性 <code>lru_clock</code>，这个属性是通过一个全局函数 <code>serverCron</code> 每隔 <code>100</code> 毫秒执行一次来更新的，记录的是当前 <code>unix</code> 时间戳。</p>
<p>最后决定删除的数据是通过 <code>lru_clock</code> 减去对象的 <code>lru</code> 属性而得出的。那么为什么 <code>Redis</code> 要这么做呢？直接取全局时间不是更准确吗？</p>
<p>这是因为这么做可以避免每次更新对象的 <code>lru</code> 属性的时候可以直接取全局属性，而不需要去调用系统函数来获取系统时间，从而提升效率（<code>Redis</code> 当中有很多这种细节考虑来提升性能，可以说是对性能尽可能的优化到极致）。</p>
<p>不过这里还有一个问题，我们看到，<code>redisObject</code> 对象中的 <code>lru</code> 属性只有 <code>24</code> 位，<code>24</code> 位只能存储 <code>194</code> 天的时间戳大小，一旦超过 <code>194</code> 天之后就会重新从 <code>0</code> 开始计算，所以这时候就可能会出现 <code>redisObject</code> 对象中的 <code>lru</code> 属性大于全局的 <code>lru_clock</code> 属性的情况。</p>
<p>正因为如此，所以计算的时候也需要分为 <code>2</code> 种情况：</p>
<ul>
<li>当全局 <code>lruclock</code> &gt; <code>lru</code>，则使用 <code>lruclock</code> - <code>lru</code> 得到空闲时间。</li>
<li>当全局 <code>lruclock</code> &lt; <code>lru</code>，则使用 <code>lruclock_max</code>（即 <code>194</code> 天） - <code>lru</code> + <code>lruclock</code> 得到空闲时间。</li>
</ul>
<p>需要注意的是，这种计算方式并不能保证抽样的数据中一定能删除空闲时间最长的。这是因为首先超过 <code>194</code> 天还不被使用的情况很少，再次只有 <code>lruclock</code> 第 <code>2</code> 轮继续超过 <code>lru</code> 属性时，计算才会出问题。</p>
<p>比如对象 <code>A</code> 记录的 <code>lru</code> 是 <code>1</code> 天，而 <code>lruclock</code> 第二轮都到 <code>10</code> 天了，这时候就会导致计算结果只有 <code>10-1=9</code> 天，实际上应该是 <code>194+10-1=203</code> 天。但是这种情况可以说又是更少发生，所以说这种处理方式是可能存在删除不准确的情况，但是本身这种算法就是一种近似的算法，所以并不会有太大影响。</p>
<h2 id="LFU-算法"><a href="#LFU-算法" class="headerlink" title="LFU 算法"></a>LFU 算法</h2><p><code>LFU</code> 全称为：<code>Least Frequently Used</code>。即：最近最少频率使用，这个主要针对的是使用频率。这个属性也是记录在<code>redisObject</code> 中的 <code>lru</code> 属性内。</p>
<p>当我们采用 <code>LFU</code> 回收策略时，<code>lru</code> 属性的高 <code>16</code> 位用来记录访问时间（last decrement time：ldt，单位为分钟），低 <code>8</code> 位用来记录访问频率（logistic counter：logc），简称 <code>counter</code>。</p>
<h3 id="访问频次递增"><a href="#访问频次递增" class="headerlink" title="访问频次递增"></a>访问频次递增</h3><p><code>LFU</code> 计数器每个键只有 <code>8</code> 位，它能表示的最大值是 <code>255</code>，所以 <code>Redis</code> 使用的是一种基于概率的对数器来实现 <code>counter</code> 的递增。r</p>
<p>给定一个旧的访问频次，当一个键被访问时，<code>counter</code> 按以下方式递增：</p>
<ol>
<li>提取 <code>0</code> 和 <code>1</code> 之间的随机数 <code>R</code>。</li>
<li><code>counter</code> - 初始值（默认为 <code>5</code>），得到一个基础差值，如果这个差值小于 <code>0</code>，则直接取 <code>0</code>，为了方便计算，把这个差值记为 <code>baseval</code>。</li>
<li>概率 <code>P</code> 计算公式为：<code>1/(baseval * lfu_log_factor + 1)</code>。</li>
<li>如果 <code>R &lt; P</code> 时，频次进行递增（<code>counter++</code>）。</li>
</ol>
<p>公式中的 <code>lfu_log_factor</code> 称之为对数因子，默认是 <code>10</code> ，可以通过参数来进行控制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lfu_log_factor <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>下图就是对数因子 <code>lfu_log_factor</code> 和频次 <code>counter</code> 增长的关系图：</p>
<p><img src="https://img2020.cnblogs.com/blog/2232223/202102/2232223-20210215094631450-531937582.png" alt="img"></p>
<p>可以看到，当对数因子 <code>lfu_log_factor</code> 为 <code>100</code> 时，大概是 <code>10M（1000万）</code> 次访问才会将访问 <code>counter</code> 增长到 <code>255</code>，而默认的 <code>10</code> 也能支持到 <code>1M（100万）</code> 次访问 <code>counter</code> 才能达到 <code>255</code> 上限，这在大部分场景都是足够满足需求的。</p>
<h3 id="访问频次递减"><a href="#访问频次递减" class="headerlink" title="访问频次递减"></a>访问频次递减</h3><p>如果访问频次 <code>counter</code> 只是一直在递增，那么迟早会全部都到 <code>255</code>，也就是说 <code>counter</code> 一直递增不能完全反应一个 <code>key</code>的热度的，所以当某一个 <code>key</code> 一段时间不被访问之后，<code>counter</code> 也需要对应减少。</p>
<p><code>counter</code> 的减少速度由参数 <code>lfu-decay-time</code> 进行控制，默认是 <code>1</code>，单位是分钟。默认值 <code>1</code> 表示：<code>N</code> 分钟内没有访问，<code>counter</code> 就要减 <code>N</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lfu-decay-time <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>具体算法如下：</p>
<ol>
<li>获取当前时间戳，转化为<strong>分钟</strong>后取低 <code>16</code> 位（为了方便后续计算，这个值记为 <code>now</code>）。</li>
<li>取出对象内的 <code>lru</code> 属性中的高 <code>16</code> 位（为了方便后续计算，这个值记为 <code>ldt</code>）。</li>
<li>当 <code>lru</code> &gt; <code>now</code> 时，默认为过了一个周期（<code>16</code> 位，最大 <code>65535</code>)，则取差值 <code>65535-ldt+now</code>：当 <code>lru</code> &lt;= <code>now</code> 时，取差值 <code>now-ldt</code>（为了方便后续计算，这个差值记为 <code>idle_time</code>）。</li>
<li>取出配置文件中的 <code>lfu_decay_time</code> 值，然后计算：<code>idle_time / lfu_decay_time</code>（为了方便后续计算，这个值记为<code>num_periods</code>）。</li>
<li>最后将<code>counter</code>减少：<code>counter - num_periods</code>。</li>
</ol>
<p>看起来这么复杂，其实计算公式就是一句话：取出当前的时间戳和对象中的 <code>lru</code> 属性进行对比，计算出当前多久没有被访问到，比如计算得到的结果是 <code>100</code> 分钟没有被访问，然后再去除配置参数 <code>lfu_decay_time</code>，如果这个配置默认为 <code>1</code>也即是 <code>100/1=100</code>，代表 <code>100</code> 分钟没访问，所以 <code>counter</code> 就减少 <code>100</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要介绍了 <code>Redis</code> 过期键的处理策略，以及当服务器内存不够时 <code>Redis</code> 的 <code>8</code> 种淘汰策略，最后介绍了 <code>Redis</code> 中的两种主要的淘汰算法 <code>LRU</code> 和 <code>LFU</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wzg6662.github.io/2020/10/03/redis%E5%86%85%E5%AD%98%E8%80%97%E5%B0%BD%E5%90%8E%E5%A4%84%E7%90%86/" data-id="ckluj5du30000v4p45l9v7uqk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-PM2-常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/wzg6662.github.io/2020/09/22/PM2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2020-09-22T02:13:42.000Z" itemprop="datePublished">2020-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/wzg6662.github.io/2020/09/22/PM2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">PM2 常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="PM2-常用命令"><a href="#PM2-常用命令" class="headerlink" title="PM2 常用命令"></a>PM2 常用命令</h2><p>$ pm2 start app.js # 启动app.js应用程序</p>
<p>$ pm2 start app.js -i 4 # cluster mode 模式启动4个app.js的应用实例 4个应用程序会自动进行负载均衡</p>
<p>$ pm2 start app.js –name=”api” # 启动应用程序并命名为 “api”</p>
<p>$ pm2 start app.js –watch # 当文件变化时自动重启应用</p>
<p>$ pm2 start script.sh # 启动 bash 脚本</p>
<p>$ pm2 list # 列表 PM2 启动的所有的应用程序</p>
<p>$ pm2 monit # 显示每个应用程序的CPU和内存占用情况</p>
<p>$ pm2 show [app-name] # 显示应用程序的所有信息</p>
<p>$ pm2 logs # 显示所有应用程序的日志</p>
<p>$ pm2 logs [app-name] # 显示指定应用程序的日志</p>
<p>$ pm2 flush</p>
<p>$ pm2 stop all # 停止所有的应用程序</p>
<p>$ pm2 stop 0 # 停止 id为 0的指定应用程序</p>
<p>$ pm2 restart all # 重启所有应用</p>
<p>$ pm2 reload all # 重启 cluster mode下的所有应用</p>
<p>$ pm2 gracefulReload all # Graceful reload all apps in cluster mode</p>
<p>$ pm2 delete all # 关闭并删除所有应用</p>
<p>$ pm2 delete 0 # 删除指定应用 id 0</p>
<p>$ pm2 scale api 10 # 把名字叫api的应用扩展到10个实例</p>
<p>$ pm2 reset [app-name] # 重置重启数量</p>
<p>$ pm2 startup # 创建开机自启动命令</p>
<p>$ pm2 save # 保存当前应用列表</p>
<p>$ pm2 resurrect # 重新加载保存的应用列表</p>
<p>$ pm2 update # Save processes, kill PM2 and restore processes</p>
<p>$ pm2 generate # Generate a sample json configuration file</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wzg6662.github.io/2020/09/22/PM2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="cklxasusq0000zwp4fhgtak81" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/PM2/" rel="tag">PM2</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/%E5%91%BD%E4%BB%A4/" rel="tag">命令</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Mysql调优" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/wzg6662.github.io/2020/08/03/Mysql%E8%B0%83%E4%BC%98/" class="article-date">
  <time datetime="2020-08-03T02:44:22.000Z" itemprop="datePublished">2020-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/wzg6662.github.io/2020/08/03/Mysql%E8%B0%83%E4%BC%98/">Mysql调优</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 聚簇索引，非聚簇索引，普通索引，唯一索引，change buffer，表锁、行锁、间隙锁以及行锁并发情况下的最大TPS是多少？还有索引为啥会选择错误？这些大家知道嘛？</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>数据库调优其实一般情况都是我们的SQL调优，SQL的调优就可以解决大部分问题了，当然也不排除SQL执行环节的调优。</p>
<p>我们所谓的调优也就是在，执行器执行之前的分析器，优化器阶段完成的，那我们开发工作中怎么去调优的呢？</p>
<p>帅丙一般在开发涉及SQL的业务都会去本地环境跑一遍SQL，用explain去看一下执行计划，看看分析的结果是否符合自己的预期，用没用到相关的索引，然后再去线上环境跑一下看看执行时间（这里只有查询语句，修改语句也无法在线上执行）。</p>
<p>遇SQL不决explain，但是这里就要说到第一个坑了。</p>
<h3 id="排除缓存干扰"><a href="#排除缓存干扰" class="headerlink" title="排除缓存干扰"></a>排除缓存干扰</h3><p>因为在MySQL8.0之前我们的数据库是存在缓存这样的情况的，我之前就被坑过，因为存在缓存，我发现我sql怎么执行都是很快，当然第一次其实不快但是我没注意到，以至于上线后因为缓存经常失效，导致rt（Response time）时高时低。</p>
<p>后面就发现了是缓存的问题，我们在执行SQL的时候，记得加上SQL NoCache去跑SQL，这样跑出来的时间就是真实的查询时间了。</p>
<p>我说一下为什么缓存会失效，而且是经常失效。</p>
<p>如果我们当前的MySQL版本支持缓存而且我们又开启了缓存，那每次请求的查询语句和结果都会以key-value的形式缓存在内存中的，大家也看到我们的结构图了，一个请求会先去看缓存是否存在，不存在才会走解析器。</p>
<p>缓存失效比较频繁的原因就是，只要我们一对表进行更新，那这个表所有的缓存都会被清空，其实我们很少存在不更新的表，特别是我之前的电商场景，可能静态表可以用到缓存，但是我们都走大数据离线分析，缓存也就没用了。</p>
<p>大家如果是8.0以上的版本就不用担心这个问题，如果是8.0之下的版本，记得排除缓存的干扰。</p>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><p>最开始提到了用执行计划去分析，我想explain是大家SQL调优都会回答到的吧。</p>
<p>因为这基本上是写SQL的必备操作，那我现在问大家一个我去阿里面试被问过的一个问题：<strong>explain你记得哪些字段，分别有什么含义？</strong></p>
<p>当时我就回答上来三个，我默认大家都是有数据库基础的，所以每个我这里不具体讨论每个字段，怕大家忘记我贴一遍图大家自己回忆一下。</p>
<p>当然我都这么问了，你们肯定也知道结果了，行数只是一个接近的数字，不是完全正确的，索引也不一定就是走最优的，是可能走错的。</p>
<p>我的总行数大概有10W行，但是我去用explain去分析sql的时候，就会发现只得到了9.4W，为啥行数只是个近视值呢？</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>看过基础章节的小伙伴都知道，MySQL中数据的单位都是页，MySQL又采用了采样统计的方法，采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p>
<p>我们数据是一直在变的，所以索引的统计信息也是会变的，会根据一个阈值，重新做统计。</p>
<p>至于MySQL索引可能走错也很好理解，如果走A索引要扫描100行，B所有只要20行，但是他可能选择走A索引，你可能会想MySQL是不是有病啊，其实不是的。</p>
<p>一般走错都是因为优化器在选择的时候发现，走A索引没有额外的代价，比如走B索引并不能直接拿到我们的值，还需要回到主键索引才可以拿到，多了一次回表的过程，这个也是会被优化器考虑进去的。</p>
<p>他发现走A索引不需要回表，没有额外的开销，所有他选错了。</p>
<p>如果是上面的统计信息错了，那简单，我们用analyze table tablename 就可以重新统计索引信息了，所以在实践中，如果你发现explain的结果预估的rows值跟实际情况差距比较大，可以采用这个方法来处理。</p>
<p>还有一个方法就是force index强制走正确的索引，或者优化SQL，最后实在不行，可以新建索引，或者删掉错误的索引。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>上面我提到了，可能需要回表这样的操作，那我们怎么能做到不回表呢？在自己的索引上就查到自己想要的，不要去主键索引查了。</p>
<p>覆盖索引</p>
<p>如果在我们建立的索引上就已经有我们需要的字段，就不需要回表了，在电商里面也是很常见的，我们需要去商品表通过各种信息查询到商品id，id一般都是主键，可能sql类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select itemId from itemCenter where size between 1 and 6</span><br></pre></td></tr></table></figure>



<p>因为商品id itemId一般都是主键，在size索引上肯定会有我们这个值，这个时候就不需要回主键表去查询id信息了。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>还是商品表举例，我们需要根据他的名称，去查他的库存，假设这是一个很高频的查询请求，你会怎么建立索引呢？</p>
<p>大家可以思考上面的回表的消耗对SQL进行优化。</p>
<p>是的建立一个，名称和库存的联合索引，这样名称查出来就可以看到库存了，不需要查出id之后去回表再查询库存了，联合索引在我们开发过程中也是常见的，但是并不是可以一直建立的，大家要思考索引占据的空间。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>刚才我举的例子其实有点生硬，正常通过商品名称去查询库存的请求是不多的，但是也不代表没有哈，真来了，难道我们去全表扫描？</p>
<h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>大家在写sql的时候，最好能利用到现有的SQL最大化利用，像上面的场景，如果利用一个模糊查询 itemname like ’敖丙%‘，这样还是能利用到这个索引的，而且如果有这样的联合索引，大家也没必要去新建一个商品名称单独的索引了。</p>
<p>很多时候我们索引可能没建对，那你调整一下顺序，可能就可以优化到整个SQL了。</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>你已经知道了前缀索引规则，那我就说一个官方帮我们优化的东西，索引下推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from itemcenter where name like &#39;敖%&#39; and size&#x3D;22 and age &#x3D; 20;</span><br></pre></td></tr></table></figure>

<p>所以这个语句在搜索索引树的时候，只能用 “敖”，找到第一个满足条件的记录ID1，当然，这还不错，总比全表扫描要好。</p>
<p>然后呢？</p>
<p>当然是判断其他条件是否满足，比如size。</p>
<p>在MySQL 5.6之前，只能从ID1开始一个个回表，到主键索引上找出数据行，再对比字段值。</p>
<p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<h3 id="唯一索引普通索引选择难题"><a href="#唯一索引普通索引选择难题" class="headerlink" title="唯一索引普通索引选择难题"></a>唯一索引普通索引选择难题</h3><p>这个在我的面试视频里面其实问了好几次了，核心是需要回答到change buffer，那change buffer又是个什么东西呢？</p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。</p>
<p>在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作，通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。</p>
<p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。</p>
<p>除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。</p>
<p>显然，如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率</p>
<p>那么，<strong>什么条件下可以使用change buffer呢？</strong></p>
<p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。</p>
<p>要判断表中是否存在这个数据，而这必须要将数据页读入内存才能判断，如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。</p>
<p>因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。</p>
<p>change buffer用的是buffer pool里的内存，因此不能无限增大，change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置，这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p>
<p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一，change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>
<h4 id="change-buffer的使用场景"><a href="#change-buffer的使用场景" class="headerlink" title="change buffer的使用场景"></a>change buffer的使用场景</h4><p>因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p>
<p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好，这种业务模型常见的就是账单类、日志类的系统。</p>
<p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价，所以，对于这种业务模式来说，change buffer反而起到了副作用。</p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>我们存在邮箱作为用户名的情况，每个人的邮箱都是不一样的，那我们是不是可以在邮箱上建立索引，但是邮箱这么长，我们怎么去建立索引呢？</p>
<p>MySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p>
<p><strong>我们是否可以建立一个区分度很高的前缀索引，达到优化和节约空间的目的呢？</strong></p>
<p>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</p>
<p>上面说过覆盖索引了，覆盖索引是不需要回表的，但是前缀索引，即使你的联合索引已经包涵了相关信息，他还是会回表，因为他不确定你到底是不是一个完整的信息，就算你是<a target="_blank" rel="noopener" href="http://www.aobing@mogu.com一个完整的邮箱去查询,他还是不知道你是否是完整的,所以他需要回表去判断一下./">www.aobing@mogu.com一个完整的邮箱去查询，他还是不知道你是否是完整的，所以他需要回表去判断一下。</a></p>
<p><strong>下面这个也是我在阿里面试面试官问过我的，很长的字段，想做索引我们怎么去优化他呢？</strong></p>
<p>因为存在一个磁盘占用的问题，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</p>
<p>我当时就回答了一个hash，把字段hash为另外一个字段存起来，每次校验hash就好了，hash的索引也不大。</p>
<p>我们都知道只要区分度过高，都可以，那我们可以采用倒序，或者删减字符串这样的情况去建立我们自己的区分度，不过大家需要注意的是，调用函数也是一次开销哟，这点当时没注意。</p>
<p>就比如本来是<a target="_blank" rel="noopener" href="http://www.aobing@qq,com/">www.aobing@qq,com</a> 其实前面的<code>www.</code>基本上是没任何区分度的，所有人的邮箱都是这么开头的，你一搜一大堆出来，放在索引还浪费内存，你可以substring()函数截取掉前面的，然后建立索引。</p>
<p>我们所有人的身份证都是区域开头的，同区域的人很多，那怎么做良好的区分呢？REVERSE（）函数翻转一下，区分度可能就高了。</p>
<p>这些操作都用到了函数，我就说一下函数的坑。</p>
<h3 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h3><p>日常开发过程中，大家经常对很多字段进行函数操作，如果对日期字段操作，浮点字符操作等等，大家需要注意的是，如果对字段做了函数计算，就用不上索引了，这是MySQL的规定。</p>
<p>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</p>
<p>需要注意的是，优化器并不是要放弃使用这个索引。</p>
<p>这个时候大家可以用一些取巧的方法，比如 select * from tradelog where id + 1 = 10000 就走不上索引，select * from tradelog where id = 9999就可以。</p>
<h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>select * from t where id = 1</p>
<p>如果id是字符类型的，1是数字类型的，你用explain会发现走了全表扫描，根本用不上索引，为啥呢？</p>
<p>因为MySQL底层会对你的比较进行转换，相当于加了 CAST( id AS signed int) 这样的一个函数，上面说过函数会导致走不上索引。</p>
<h3 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h3><p>还是一样的问题，如果两个表的字符集不一样，一个是utf8mb4，一个是utf8，因为utf8mb4是utf8的超集，所以一旦两个字符比较，就会转换为utf8mb4再比较。</p>
<p>转换的过程相当于加了CONVERT(id USING utf8mb4)函数，那又回到上面的问题了，用到函数就用不上索引了。</p>
<p>还有大家一会可能会遇到mysql突然卡顿的情况，那可能是MySQLflush了。</p>
<h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><p>redo log大家都知道，也就是我们对数据库操作的日志，他是在内存中的，每次操作一旦写了redo log就会立马返回结果，但是这个redo log总会找个时间去更新到磁盘，这个操作就是flush。</p>
<p>在更新之前，当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。</p>
<p>内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页“。</p>
<p><strong>那什么时候会flush呢？</strong></p>
<ol>
<li>InnoDB的redo log写满了，这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。</li>
<li>系统内存不足，当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。</li>
</ol>
<blockquote>
<p>你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿redo log出来应用不就行了？</p>
</blockquote>
<p>这里其实是从性能考虑的，如果刷脏页一定会写盘，就保证了每个数据页有两种状态：</p>
<ul>
<li>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</li>
<li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。</li>
</ul>
<ol>
<li>MySQL认为系统“空闲”的时候，只要有机会就刷一点“脏页”。</li>
<li>MySQL正常关闭，这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li>
</ol>
<p><strong>那我们怎么做才能把握flush的时机呢？</strong></p>
<p>Innodb刷脏页控制策略，我们每个电脑主机的io能力是不一样的，你要正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。</p>
<p>这就要用到innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力，这个值建议设置成磁盘的IOPS，磁盘的IOPS可以通过fio这个工具来测试。</p>
<p>正确地设置innodb_io_capacity参数，可以有效的解决这个问题。</p>
<p>这中间有个有意思的点，刷脏页的时候，旁边如果也是脏页，会一起刷掉的，并且如果周围还有脏页，这个连带责任制会一直蔓延，这种情况其实在机械硬盘时代比较好，一次IO就解决了所有问题，</p>
<p>但是现在都是固态硬盘了，innodb_flush_neighbors=0这个参数可以不产生连带制，在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。</p>
<p>资料参考：《MySQL实战》、《高性能MySQL》、《丁奇MySQL47讲》</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>应该还不算全，行锁、表锁、间隙锁、同步场景等等都没怎么提到，因为他们的场景比较复杂，每种都可以单独开一篇了，丁奇的MySQL里面算是很全了，还有就是高性能MySQL大家可以展开看看，要是懒也可以等我总结。</p>
<p>每个点我也没多仔细的讲解，主要是篇幅原因，其实每个点在MySQL相关书籍都是很多篇幅才介绍完的，我就做个总结，对具体的概念不了解可以用搜索引擎查询相关概念，不过我想我说得还算通俗易懂。</p>
<p>转自公众号：三太子敖丙（<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&amp;mid=2453143331&amp;idx=1&amp;sn=e387e1b1beb4cd516ee2d67ce934115e&amp;scene=21#wechat_redirect%EF%BC%89">https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&amp;mid=2453143331&amp;idx=1&amp;sn=e387e1b1beb4cd516ee2d67ce934115e&amp;scene=21#wechat_redirect）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wzg6662.github.io/2020/08/03/Mysql%E8%B0%83%E4%BC%98/" data-id="ckm0atqc30000x4p471h1cmdv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/Mysql/" rel="tag">Mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-搭载hexo + github部署" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/wzg6662.github.io/2019/03/03/%E6%90%AD%E8%BD%BDhexo%20+%20github%E9%83%A8%E7%BD%B2/" class="article-date">
  <time datetime="2019-03-03T10:18:23.000Z" itemprop="datePublished">2019-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/wzg6662.github.io/2019/03/03/%E6%90%AD%E8%BD%BDhexo%20+%20github%E9%83%A8%E7%BD%B2/">搭载hexo + github部署</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-搭建博客"><a href="#1-搭建博客" class="headerlink" title="1.搭建博客"></a>1.搭建博客</h1><ul>
<li><p>开源博客系统：<a target="_blank" rel="noopener" href="https://hexo.io/">https://hexo.io/</a></p>
</li>
<li><ul>
<li>使用场景</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>新一代年轻化的个人博客平台，以前是WordPress比较多。</li>
<li>博客平台，产品展示，api文档</li>
<li>vue官方文档等</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>依赖环境</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>node </li>
<li>git</li>
</ul>
</li>
</ul>
</li>
<li><p>安装步骤</p>
</li>
<li><ul>
<li>安装git</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install git-core</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>安装NodeJS</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;有源码的安装方式，但容易出现hexo 命令不存在，另外一种安装方式</span><br><span class="line">wget -qO- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.0&#x2F;install.sh | bash</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重新进入终端, 执行命令</span><br><span class="line">nvm install stable</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;验证</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>切换cnpm（淘宝镜像）</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>npm install -g cnpm –registry=<a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li>安装Hexo</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>



<ul>
<li><ul>
<li>建立博客</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;新建项目</span><br><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;进入文件夹</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;安装依赖包</span><br><span class="line">cnpm install</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成静态网页</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>启动服务</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server -p 80</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>新建文章</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;新建文章，在source目录</span><br><span class="line">hexo new &quot;title&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编辑文件后生成静态文件，再启动文件,通常用于生产环境（production mode），缩写是 hexo g</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure>



<h1 id="2-托管在github"><a href="#2-托管在github" class="headerlink" title="2.托管在github"></a>2.托管在github</h1><h2 id="创建项目代码库"><a href="#创建项目代码库" class="headerlink" title="\创建项目代码库**"></a><strong><em>\</em>创建项目代码库**</strong></h2><p>点击 New repository 开始创建，步骤及注意事项见下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY1ZTA5MzBjMi5wbmc" alt="img"></p>
<h2 id="配置-SSH-密钥"><a href="#配置-SSH-密钥" class="headerlink" title="\配置 SSH 密钥**"></a><strong><em>\</em>配置 SSH 密钥**</strong></h2><p>只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步，在你第一次新建的文件夹里面（如：我的文件夹为：Ｅ\TRHX_Blog） Git Bash Here 输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;your email@example.com&quot;</span> </span><br><span class="line">//引号里面填写你的邮箱地址，比如我的是tanrenhou@126.com</span><br></pre></td></tr></table></figure>

<p>之后会出现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.  </span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/you/.ssh/id_rsa):</span><br><span class="line">//到这里可以直接回车将密钥按默认文件进行存储</span><br></pre></td></tr></table></figure>

<p>然后会出现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):  </span><br><span class="line">//这里是要你输入密码，其实不需要输什么密码，直接回车就行 </span><br><span class="line">Enter same passphrase again:  </span><br></pre></td></tr></table></figure>

<p>接下来屏幕会显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in &#x2F;c&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa.  </span><br><span class="line">Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa.pub.</span><br><span class="line">The key fingerprint is:  </span><br><span class="line"></span><br><span class="line">这里是各种字母数字组成的字符串，结尾是你的邮箱  </span><br><span class="line"></span><br><span class="line">The key&#39;s randomart image is:  </span><br><span class="line"></span><br><span class="line">这里也是各种字母数字符号组成的字符串  </span><br></pre></td></tr></table></figure>

<p>运行以下命令，将公钥的内容复制到系统粘贴板上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<h2 id="在-GitHub-账户中添加你的公钥"><a href="#在-GitHub-账户中添加你的公钥" class="headerlink" title="\在 GitHub 账户中添加你的公钥**"></a><strong><em>\</em>在 GitHub 账户中添加你的公钥**</strong></h2><p>① 登陆 GitHub，进入 Settings：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY2MDZlNzU1OC5wbmc" alt="img"></p>
<p>② 点击 SSH and GPG Keys：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY2MjJiNDU4OC5wbmc" alt="img"></p>
<p>③ 选择 New SSH key：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY2M2ViMWFiMi5wbmc" alt="img"></p>
<p>④ 粘贴密钥：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY2YmMxZmM4Ny5wbmc" alt="img"></p>
<h2 id="•-测试"><a href="#•-测试" class="headerlink" title="\• 测试**"></a><strong><em>\</em>• 测试**</strong></h2><p>输入以下命令：注意：<a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;">&#103;&#105;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;</a>不要做任何更改！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
<p>之后会显示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY2ZTNiNDgwMy5wbmc" alt="img"></p>
<p>输入 yes 后会显示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY3MDJjNDZkNi5wbmc" alt="img"></p>
<p>此时表示设置正确</p>
<h2 id="配置-Git-个人信息"><a href="#配置-Git-个人信息" class="headerlink" title="\配置 Git 个人信息**"></a><strong><em>\</em>配置 Git 个人信息**</strong></h2><p>Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;此处填你的用户名&quot;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git config --global user.email  &quot;此处填你的邮箱&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
<p>到此为止 SSH Key 配置成功，本机已成功连接到 Github</p>
<h1 id="●-将本地的-Hexo-文件更新到-Github-的库中"><a href="#●-将本地的-Hexo-文件更新到-Github-的库中" class="headerlink" title="\● 将本地的 Hexo 文件更新到 Github 的库中**"></a><strong><em>\</em>● 将本地的 Hexo 文件更新到 Github 的库中**</strong></h1><p>① 登录 Github 打开自己的项目 your name.github.io<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY3MjBjY2FlMC5wbmc" alt="img"></p>
<p>② 鼠标移到 Clone or download 按钮，选择 Use SSH<br><img src="https://img-blog.csdnimg.cn/20190816220246218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>③ 一键复制地址<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY3NmNiM2RhNC5wbmc" alt="img"></p>
<p>④ 打开你创建的 Hexo 文件夹（如：E:\TRHX_Blog\Hexo），右键用记事本（Notepad++或者VS code等都可以）打开该文件夹下的 _config.yml 文件<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY3OGI4YmEzZS5wbmc" alt="img"></p>
<p>⑤ 按下图修改 _config.yml 文件并保存<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjUvNWM5OGY3ZTExZWVkNy5wbmc" alt="img"></p>
<p>⑥ 在 Hexo 文件夹下分别执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g   </span><br><span class="line"></span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>或者直接执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>

<p>执行完之后会让你输入你的 Github 的账号和密码，如果此时报以下错误，说明你的 deployer 没有安装成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>

<p>需要执行以下命令再安装一次：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>再执行 <code>hexo g -d</code>，你的博客就会部署到 Github 上了</p>
<p>⑦ 访问博客</p>
<p>你的博客地址：https://你的用户名.github.io，比如我的是：<a target="_blank" rel="noopener" href="https://trhx.github.io/">https://trhx.github.io</a> ,现在每个人都可以通过此链接访问你的博客了</p>
<h2 id="可能遇到的问题问题："><a href="#可能遇到的问题问题：" class="headerlink" title="可能遇到的问题问题："></a>可能遇到的问题问题：</h2><p><strong>1.可以访问到博客，但是无样式</strong></p>
<p>​        ①修改GitHub上的Reository名字：改为xxx.github.io</p>
<p>​        ②修改——config.yml的值，url：//GitHub上给的地址</p>
<p>​                                                        root://GitHub上给的地址</p>
<p><strong>2.hexo d 无法推到github上</strong></p>
<p>原因是2020-10-1后默认分支不叫master了，叫main，我把main改为master就可正常push</p>
<p><strong>3.输入以下命令可能出错</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>Warning: Permanently added the RSA host key for IP address ‘xxx.xxx.xx.xx’ to the list of known host</p>
<p>那条警告的大概意思就是：警告：为IP地址13.229.188.59的主机（RSA连接的）持久添加到hosts文件中，那就来添加吧！</p>
<p>解决办法：<br><u>linux环境</u><br>　　<br>打开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>

<p>添加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13.229.188.59　　github.com</span><br></pre></td></tr></table></figure>

<p> <u>Windows环境：</u><br>打开</p>
<p>C:\Windows\System32\drivers\etc\hosts<br>添加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13.229.188.59　　github.com</span><br></pre></td></tr></table></figure>

<p> <strong>4.解决国内无法访问github pages的方法</strong></p>
<p>你的github.pages还能正常访问吗？<br>最近很多人反馈我的github.io不能正常访问了<br>我来告诉你解决方案，修改dns服务器就可以了，修改为114.114.114.114</p>
<p>具体怎么操作的，控制面板-网络和internet - 网络和共享中心 （选择你的网络进入）- 属性-IPv4-使用下面的DNS服务器地址-修改为114.114.114.114</p>
<h1 id="3-编辑文本"><a href="#3-编辑文本" class="headerlink" title="3.编辑文本"></a>3.编辑文本</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. \---</span><br><span class="line">2. layout: 页面布局（配合主题文档使用）</span><br><span class="line">3. title: 文章名称</span><br><span class="line">4. date: 文章日期</span><br><span class="line">5. comments: 文章是否开启评论</span><br><span class="line">6. photos: 文章封面图（仅部分主题支持）</span><br><span class="line">7. tags: </span><br><span class="line">8.   \- 文章标签一</span><br><span class="line">9.   \- 文章标签二</span><br><span class="line">10. categories: 文章分类</span><br><span class="line">11. description: 文章描述，即要在首页显示的摘要（仅部分主题支持）</span><br><span class="line">12. \---</span><br><span class="line">13.  </span><br><span class="line">14. 这里是摘要</span><br><span class="line">15.  </span><br><span class="line">16. &lt;!-- more --&gt;</span><br><span class="line">17.  </span><br><span class="line">18. 这里是正文</span><br><span class="line">19.  </span><br><span class="line">20. 注意：description 和 &lt;!-- more --&gt; 方式显示摘要二选一即可，部分主题不支持description，每个配置英文冒号后面要空一格，不同主题配置有所差异，具体要参考主题文档</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://wzg6662.github.io/2019/03/03/%E6%90%AD%E8%BD%BDhexo%20+%20github%E9%83%A8%E7%BD%B2/" data-id="cklu9ptob0001uvp4gfmw8y0l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/github/" rel="tag">github</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/hexo/" rel="tag">hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/%E6%95%99%E7%A8%8B/" rel="tag">教程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Typora快捷键" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/wzg6662.github.io/2019/03/03/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="article-date">
  <time datetime="2019-03-03T03:23:22.000Z" itemprop="datePublished">2019-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/wzg6662.github.io/2019/03/03/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/">Typora快捷键</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="windows快捷键："><a href="#windows快捷键：" class="headerlink" title="windows快捷键："></a>windows快捷键：</h2><ul>
<li>无序列表：输入-之后输入空格</li>
<li>有序列表：输入数字+“.”之后输入空格</li>
<li>任务列表：-[空格]空格 文字</li>
<li>标题：ctrl+数字</li>
<li>表格：ctrl+t</li>
<li>生成目录：<code>[TOC]</code>按回车</li>
<li>选中一整行：ctrl+l</li>
<li>选中单词：ctrl+d</li>
<li>选中相同格式的文字：ctrl+e</li>
<li>跳转到文章开头：ctrl+home</li>
<li>跳转到文章结尾：ctrl+end</li>
<li>搜索：ctrl+f</li>
<li>替换：ctrl+h</li>
<li>引用：输入&gt;之后输入空格</li>
<li>代码块：ctrl+alt+f</li>
<li>加粗：ctrl+b</li>
<li>倾斜：ctrl+i</li>
<li>下划线：ctrl+u</li>
<li>删除线：alt+shift+5</li>
<li>插入图片：直接拖动到指定位置即可或者ctrl+shift+i</li>
<li>插入链接：ctrl + k</li>
</ul>
<h2 id="Mac中的快捷键："><a href="#Mac中的快捷键：" class="headerlink" title="Mac中的快捷键："></a>Mac中的快捷键：</h2><ol>
<li>最大标题：command + 1 或者：#</li>
<li>大标题：command + 2 或者：##</li>
<li>标准标题：command + 3 或者：###</li>
<li>中标题：command + 4 或者：####</li>
<li>小标题：command + 5 或者：#####</li>
<li>插入表格：command + T</li>
<li>插入代码：command + alt +c</li>
<li>行间公式 command + Alt + b</li>
<li>段落：command + 0</li>
<li>竖线 ： command + Alt +q</li>
<li>有序列表（1. 2.） ：输入数字+“.”之后输入空格 或者：command + Alt + o</li>
<li>黑点标记：command + Alt + u</li>
<li>隔离线shift + command + -</li>
<li>超链接：command + Alt + l</li>
<li>插入链接：command +k</li>
<li>下划线：command +u</li>
<li>加粗：command +b</li>
<li>搜索：command +f</li>
</ol>
<p>补充：</p>
<h2 id="一：菜单栏"><a href="#一：菜单栏" class="headerlink" title="一：菜单栏"></a>一：菜单栏</h2><ul>
<li>文件：alt+F</li>
<li>编辑：alt+E</li>
<li>段落：alt+P</li>
<li>格式：alt+O</li>
<li>视图：alt+V</li>
<li>主题：alt+T</li>
<li>帮助：alt+H</li>
</ul>
<h2 id="二：文件"><a href="#二：文件" class="headerlink" title="二：文件"></a>二：文件</h2><ul>
<li>新建：Ctrl+N</li>
<li>新建窗口：Ctrl+Shift+N</li>
<li>打开：Ctrl+O</li>
<li>快速打开：Ctrl+P</li>
<li>保存：Ctrl+S</li>
<li>另存为：Ctrl+Shift+S</li>
<li>偏好：Ctrl+,</li>
<li>关闭：Ctrl+W</li>
</ul>
<h2 id="三：编辑"><a href="#三：编辑" class="headerlink" title="三：编辑"></a>三：编辑</h2><ul>
<li>撤销：Ctrl+Z</li>
<li>重做：Ctrl+Y</li>
<li>剪切：Ctrl+X</li>
<li>复制：Ctrl+C</li>
<li>粘贴：Ctrl+V</li>
<li>复制为MarkDown：Ctrl+Shift+C</li>
<li>粘贴为纯文本：Ctrl+Shift+V</li>
<li>全选：Ctrl+A</li>
<li>选中当前行/句：Ctrl+L</li>
<li>选中当前格式文本：Ctrl+E</li>
<li>选中当前词：Ctrl+D</li>
<li>跳转到文首：Ctrl+Home</li>
<li>跳转到所选内容：Ctrl+J</li>
<li>跳转到文末：Ctrl+End</li>
<li>查找：Ctrl+F</li>
<li>查找下一个：F3</li>
<li>查找上一个：Shift+F3</li>
<li>替换：Ctrl+H</li>
</ul>
<h2 id="四：段落"><a href="#四：段落" class="headerlink" title="四：段落"></a>四：段落</h2><ul>
<li>标题：Ctrl+1/2/3/4/5</li>
<li>段落：Ctrl+0</li>
<li>增大标题级别：Ctrl+=</li>
<li>减少标题级别：Ctrl+-</li>
<li>表格：Ctrl+T</li>
<li>代码块：Ctrl+Shift+K</li>
<li>公式块：Ctrl+Shift+M</li>
<li>引用：Ctrl+Shift+Q</li>
<li>有序列表：Ctrl+Shift+[</li>
<li>无序列表：Ctrl+Shift+]</li>
<li>增加缩进：Ctrl+]</li>
<li>减少缩进：Ctrl+[</li>
</ul>
<h2 id="五：格式"><a href="#五：格式" class="headerlink" title="五：格式"></a>五：格式</h2><ul>
<li>加粗：Ctrl+B</li>
<li>斜体：Ctrl+I</li>
<li>下划线：Ctrl+U</li>
<li>代码：Ctrl+Shift+`</li>
<li>删除线：Alt+Shift+5</li>
<li>超链接：Ctrl+K</li>
<li>图像：Ctrl+Shift+I</li>
<li>清除样式：Ctrl+</li>
</ul>
<h2 id="六：视图"><a href="#六：视图" class="headerlink" title="六：视图"></a>六：视图</h2><ul>
<li>显示隐藏侧边栏：Ctrl+Shift+L</li>
<li>大纲视图：Ctrl+Shift+1</li>
<li>文档列表视图：Ctrl+Shift+2</li>
<li>文件树视图：Ctrl+Shift+3</li>
<li>源代码模式：Ctrl+/</li>
<li>专注模式：F8</li>
<li>打字机模式：F9</li>
<li>切换全屏：F11</li>
<li>实际大小：Ctrl+Shift+0</li>
<li>放大：Ctrl+Shift+=</li>
<li>缩小：Ctrl+Shift+-</li>
<li>应用内窗口切换：Ctrl+Tab</li>
<li>打开DevTools：Shift+F12</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wzg6662.github.io/2019/03/03/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/" data-id="cklu9pto80000uvp432gs62cs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/Typora/" rel="tag">Typora</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/wzg6662.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/wzg6662.github.io/2018/12/11/hello-world/" class="article-date">
  <time datetime="2018-12-11T14:18:23.000Z" itemprop="datePublished">2018-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/wzg6662.github.io/2018/12/11/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wzg6662.github.io/2018/12/11/hello-world/" data-id="cklt8dphi0000c4p448n47pvj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/Mysql/" rel="tag">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/PM2/" rel="tag">PM2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="tag">单例模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/%E5%91%BD%E4%BB%A4/" rel="tag">命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="tag">快捷键</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/%E6%95%99%E7%A8%8B/" rel="tag">教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/wzg6662.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/wzg6662.github.io/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/wzg6662.github.io/tags/PM2/" style="font-size: 10px;">PM2</a> <a href="/wzg6662.github.io/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/wzg6662.github.io/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/wzg6662.github.io/tags/git/" style="font-size: 10px;">git</a> <a href="/wzg6662.github.io/tags/github/" style="font-size: 20px;">github</a> <a href="/wzg6662.github.io/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/wzg6662.github.io/tags/linux/" style="font-size: 10px;">linux</a> <a href="/wzg6662.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">单例模式</a> <a href="/wzg6662.github.io/tags/%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">命令</a> <a href="/wzg6662.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 10px;">快捷键</a> <a href="/wzg6662.github.io/tags/%E6%95%99%E7%A8%8B/" style="font-size: 10px;">教程</a> <a href="/wzg6662.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/wzg6662.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/wzg6662.github.io/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/wzg6662.github.io/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/wzg6662.github.io/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/wzg6662.github.io/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/wzg6662.github.io/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/wzg6662.github.io/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/wzg6662.github.io/2021/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">设计模式 - 单例模式</a>
          </li>
        
          <li>
            <a href="/wzg6662.github.io/2021/03/03/github-%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/">github 国内镜像</a>
          </li>
        
          <li>
            <a href="/wzg6662.github.io/2020/10/03/redis%E5%86%85%E5%AD%98%E8%80%97%E5%B0%BD%E5%90%8E%E5%A4%84%E7%90%86/">Redis内存耗尽后会怎么样处理？</a>
          </li>
        
          <li>
            <a href="/wzg6662.github.io/2020/09/22/PM2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">PM2 常用命令</a>
          </li>
        
          <li>
            <a href="/wzg6662.github.io/2020/08/03/Mysql%E8%B0%83%E4%BC%98/">Mysql调优</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Wuzg<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/wzg6662.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/wzg6662.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/wzg6662.github.io/fancybox/jquery.fancybox.css">

  
<script src="/wzg6662.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/wzg6662.github.io/js/script.js"></script>




  </div>
</body>
</html>